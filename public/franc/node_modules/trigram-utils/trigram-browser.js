(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.trigram = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function (f) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }
    g.collapse = f();
  }
})(function () {
  var define, module, exports;
  return function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }
          var p = n[i] = {
            exports: {}
          };
          e[i][0].call(p.exports, function (r) {
            var n = e[i][1][r];
            return o(n || r);
          }, p, p.exports, r, e, n, t);
        }
        return n[i].exports;
      }
      for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
      return o;
    }
    return r;
  }()({
    1: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.collapseWhiteSpace = collapseWhiteSpace;
      /**
       * @typedef {'html'|'js'} Style
       *
       * @typedef Options
       *   Configuration.
       * @property {Style} [style='js']
       *   Style of white space to support.
       * @property {boolean} [preserveLineEndings=false]
       *   Whether to collapse white space containing a line ending to that line
       *   ending.
       *   The default is to collapse to a single space.
       * @property {boolean} [trim=false]
       *   Whether to drop white space at the start and end of `value`.
       *   The default is to keep it.
       */

      var js = /\s+/g;
      var html = /[\t\n\v\f\r ]+/g;

      /**
       * Collapse white space.
       *
       * @param {string} value
       *   Value to collapse white space in.
       * @param {Style|Options} [options='js']
       *   Configuration.
       * @returns {string}
       *   Value with collapsed white space.
       */
      function collapseWhiteSpace(value, options) {
        if (!options) {
          options = {};
        } else if (typeof options === 'string') {
          options = {
            style: options
          };
        }
        var replace = options.preserveLineEndings ? replaceLineEnding : replaceSpace;
        return String(value).replace(options.style === 'html' ? html : js, options.trim ? trimFactory(replace) : replace);
      }

      /**
       * Replace white space with a line ending as that line ending and otherwise a
       * space.
       *
       * @param {string} value
       * @returns {string}
       */
      function replaceLineEnding(value) {
        var match = /\r?\n|\r/.exec(value);
        return match ? match[0] : ' ';
      }

      /**
       * Replace white space with a space.
       *
       * @returns {string}
       */
      function replaceSpace() {
        return ' ';
      }

      /**
       * @param {(value: string) => string} replace
       */
      function trimFactory(replace) {
        return dropOrReplace;

        /**
         * Replace white space with nothing if it starts or ends the string.
         * Calls `replace` otherwise.
         *
         * @param {string} value
         * @param {number} index
         * @param {string} all
         * @returns {string}
         */
        function dropOrReplace(value, index, all) {
          return index === 0 || index + value.length === all.length ? '' : replace(value);
        }
      }
    }, {}]
  }, {}, [1])(1);
});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(require,module,exports){
(function (global){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function (f) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }
    g.ngram = f();
  }
})(function () {
  var define, module, exports;
  return function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }
          var p = n[i] = {
            exports: {}
          };
          e[i][0].call(p.exports, function (r) {
            var n = e[i][1][r];
            return o(n || r);
          }, p, p.exports, r, e, n, t);
        }
        return n[i].exports;
      }
      for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
      return o;
    }
    return r;
  }()({
    1: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bigram = void 0;
      exports.nGram = nGram;
      exports.trigram = void 0;
      var bigram = exports.bigram = nGram(2);
      var trigram = exports.trigram = nGram(3);

      /**
       * Factory returning a function that converts a value string to n-grams.
       *
       * @param {number} n
       */
      function nGram(n) {
        if (typeof n !== 'number' || Number.isNaN(n) || n < 1 || n === Number.POSITIVE_INFINITY) {
          throw new Error('`' + n + '` is not a valid argument for `n-gram`');
        }
        return grams;

        /**
         * Create n-grams from a given value.
         *
         * @template {string|Array<unknown>} T
         * @param {T} [value]
         * @returns {T extends any[] ? T : Array<string>}
         */
        function grams(value) {
          /** @type {T extends any[] ? T : Array<string>} */
          // @ts-expect-error: pretty sure this is fine.
          var nGrams = [];
          if (value === null || value === undefined) {
            return nGrams;
          }
          var source = typeof value.slice === 'function' ? value : String(value);
          var index = source.length - n + 1;
          if (index < 1) {
            return nGrams;
          }
          while (index--) {
            nGrams[index] = source.slice(index, index + n);
          }
          return nGrams;
        }
      }
    }, {}]
  }, {}, [1])(1);
});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asDictionary = asDictionary;
exports.asTuples = asTuples;
exports.clean = clean;
exports.trigrams = trigrams;
exports.tuplesAsDictionary = tuplesAsDictionary;
var _ngramBrowser = require("../n-gram/ngram-browser.js");
var _collapseBrowser = require("../collapse-white-space/collapse-browser.js");
/**
 * @typedef {[string, number]} TrigramTuple
 * @typedef {TrigramTuple[]} TrigramTuples
 * @typedef {Record<string, number>} TrigramDictionary
 */

var own = {}.hasOwnProperty;

/**
 * Clean `value`.
 * Removed general non-important (as in, for language detection) punctuation
 * marks, symbols, and digits.
 *
 * @param {string|null} [value]
 * @returns {string}
 */
function clean(value) {
  if (value === null || value === undefined) {
    return '';
  }
  return (0, _collapseBrowser.collapseWhiteSpace)(String(value).replace(/[\u0021-\u0040]+/g, ' ')).trim().toLowerCase();
}

/**
 * Get clean, padded, trigrams.
 *
 * @param {string} [value]
 * @returns {string[]}
 */
function trigrams(value) {
  return (0, _ngramBrowser.trigram)(' ' + clean(value) + ' ');
}

/**
 * Get an `Object` with trigrams as its attributes, and their occurence count as
 * their values.
 *
 * @param {string} value
 * @returns {TrigramDictionary}
 */
function asDictionary(value) {
  var values = trigrams(value);
  /** @type {TrigramDictionary} */
  var dictionary = {};
  var index = -1;
  while (++index < values.length) {
    if (own.call(dictionary, values[index])) {
      dictionary[values[index]]++;
    } else {
      dictionary[values[index]] = 1;
    }
  }
  return dictionary;
}

/**
 * Get an `Array` containing trigram--count tuples from a given value.
 *
 * @param {string} value
 * @returns {TrigramTuples}
 */
function asTuples(value) {
  var dictionary = asDictionary(value);
  /** @type {TrigramTuples} */
  var tuples = [];
  /** @type {string} */
  var trigram;
  for (trigram in dictionary) {
    if (own.call(dictionary, trigram)) {
      tuples.push([trigram, dictionary[trigram]]);
    }
  }
  tuples.sort(sort);
  return tuples;
}

/**
 * Get an `Array` containing trigram--count tuples from a given value.
 *
 * @param {TrigramTuples} tuples
 * @returns {TrigramDictionary}
 */
function tuplesAsDictionary(tuples) {
  /** @type {TrigramDictionary} */
  var dictionary = {};
  var index = -1;
  while (++index < tuples.length) {
    dictionary[tuples[index][0]] = tuples[index][1];
  }
  return dictionary;
}

/**
 * Deep regular sort on item at `1` in both `Object`s.
 *
 * @param {TrigramTuple} a
 * @param {TrigramTuple} b
 * @returns {number}
 */
function sort(a, b) {
  return a[1] - b[1];
}

},{"../collapse-white-space/collapse-browser.js":1,"../n-gram/ngram-browser.js":2}]},{},[3])(3)
});
